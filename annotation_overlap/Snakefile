# This module takes a list of bed files and compute the pair-wise distance between them (intersection / union)

def get_all_names(config_data):
    out = []
    for name in config_data:
        out.append(name)
    return out

def get_all_pairs(config_data, taskname):
    out = []
    names = get_all_names(config_data)
    n = len(names)
    for i in range(n):
        for j in range(i + 1):
            out.append('result/{taskname}__{data1}__{data2}.txt'.format(data1=names[i], data2=names[j], taskname=taskname))
    return out

rule compute_distances:
    input:
        file1 = lambda wildcards: config[wildcards.taskname][wildcards.data1],
        file2 = lambda wildcards: config[wildcards.taskname][wildcards.data2]
    output:
        temp('result/{taskname}__{data1}__{data2}.txt')
    shell:
        'bedtools jaccard -a <( sort -k1,1 -k2,2n {input.file1}) -b <( sort -k1,1 -k2,2n {input.file2}) > {output}'

rule collect_result:
    input:
        pairs = lambda wildcards: get_all_pairs(config[wildcards.taskname], wildcards.taskname)
    output:
        'result/distance.{taskname}.csv'
    shell:
        'python scripts/collect_result.py --files {input.pairs} --out {output}'

rule rmd:
    input:
        csv = 'result/distance.{taskname}.csv'
    output:
        temp('report/distance.{taskname}.Rmd')
    run:
        rmd = '''---
title: "Deep brain - Similarity between genomic annotation"
output:
  html_document:
    number_sections: true
    toc: true
    toc_depth: 3
date: "`r format(Sys.time(), '%d %B, %Y')`"
---

```{{r setup}}
knitr::opts_knit$set(root.dir = '../')
```

# Distance between annotations

Here we only consider binary labeled data and the similarity is defined as Jaccard distance, namely:
$$\\begin{{align}}
dist(A, B) = \\frac{{|A \cap B|}}{{|A \cup B|}}
\end{{align}}$$

Alternatively, we can use the asymmetric similarity between $A$ and $B$:
$$\\begin{{align}}
dist(A, B) &= \\frac{{|A \cap B|}}{{|A|}} \\
dist(B, A) &= \\frac{{|A \cap B|}}{{|B|}}
\end{{align}}$$

# Jaccard Similarity

```{{r}}
library(ggplot2)
dist <- read.table('{input}', sep = ',', header = T)
dist <- as.data.frame(dist)
ggplot(dist, aes(name_1, name_2)) +
    geom_tile(aes(fill = jaccard)) +
    geom_text(aes(label = round(jaccard, 2)), size = 1.5) +
    scale_fill_gradient(low = "white", high = "red")  +
    ggtitle('Pairwise Jaccard Similarity') +
    labs(x = 'dataset', y = 'dataset') +
    theme(axis.text.x=element_text(angle=90,hjust=1))
```

# Asymmetric Similarity

```{{r}}
identical.ind <- dist$name_1 == dist$name_2
dist.identical <- dist[identical.ind, ]
dist.notidentical <- dist[!identical.ind, ]
temp <- dist.notidentical
temp.name_1 <- temp$name_1
temp$name_1 <- temp$name_2
temp$name_2 <- temp.name_1
dist.asymetric <- rbind(dist.notidentical, temp, dist.identical)
dist.asymetric$asymetric <- apply(dist.asymetric, 1, function(x){{
    return(x['intersection'] / dist.identical[dist.identical$name_1 == x['name_1'], 'intersection'])
}})
dist.jaccard$name_1 <- factor(dist.jaccard$name_1, sort(dataname))
dist.jaccard$name_2 <- factor(dist.jaccard$name_2, sort(dataname))
ggplot(dist.jaccard, aes(name_1, name_2)) +
    geom_tile(aes(fill = asymetric)) +
    geom_text(aes(label = round(asymetric, 2)), size = 1.5) +
    scale_fill_gradient(low = "white", high = "red")  +
    ggtitle('Pairwise Asymmetric Similarity') +
    labs(x = 'dataset', y = 'dataset') +
    theme(axis.text.x=element_text(angle=90,hjust=1))
```
'''.format(input=input.csv)
        o = open(output[0], 'w')
        o.write(rmd)
        o.close()

rule html:
    input:
        'report/distance.{taskname}.Rmd'
    output:
        'report/distance.{taskname}.html'
    shell:
        '''Rscript -e "rmarkdown::render('./{input[0]}')"'''
