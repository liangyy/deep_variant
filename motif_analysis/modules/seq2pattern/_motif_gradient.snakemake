# This module takes sequences and model as input and generate feather file containing the gradient of crossentropy of the given label w.r.t
# first convolutional layer neuron (after ReLU)
# For each sequence, the spatial information will be collapsed by taking the maximum value

rule get_pattern_grad_pos:
    input:
        p = 'data/{dataname}.{data}/selected_positive.hdf5',
        model = config['model']['path']
    output:
        op = 'pattern/{model}/{{dataname}}.{{data}}/motif_gradient/pattern_positive.feather'.format(model=config['model']['name'])
    params:
        idx = config['model']['first_layer_idx'],
        label_idx = lambda wildcards: config[wildcards.dataname][wildcards.data]['label_num'],
        true_label = 1
    shell:
        'python scripts/motif_gradient.py --model {input.model} \
        --input {input.p} \
        --output {output.op} \
        --idx {params.idx} \
        --label_idx {params.label_idx} \
        --true_label {params.true_label}'

rule get_pattern_grad_neg:
    input:
        n = 'data/{{dataname}}.{{data}}/selected_negative.hdf5',
        model = config['model']['path']
    output:
        on = 'pattern/{model}/{{dataname}}.{{data}}/motif_gradient/pattern_negative.feather'.format(model=config['model']['name'])
    params:
        idx = config['model']['first_layer_idx'],
        label_idx = lambda wildcards: config[wildcards.dataname][wildcards.data]['label_num'],
        true_label = 0
    shell:
        'python scripts/motif_gradient.py --model {input.model} \
        --input {input.n} \
        --output {output.on} \
        --idx {params.idx} \
        --label_idx {params.label_idx} \
        --true_label {params.true_label}'

rule report_grad_gen_rmd:
    input:
        p = 'pattern/{model}/{{dataname}}.{{data}}/motif_gradient/pattern_positive.feather'.format(model=config['model']['name']),
        n = 'pattern/{model}/{{dataname}}.{{data}}/motif_gradient/pattern_negative.feather'.format(model=config['model']['name'])
    output:
        o = temp('report/{model}/{{dataname}}.{{data}}_motif_gradient.Rmd'.format(model=config['model']['name']))
    params:
        model = config['model']['name'],
        data = '{dataname}.{data}',
        envir = '../../',
    run:
        rmd = '''---
title: "Deep brain - Motif Analysis - motif gradient"
output:
    html_document:
        number_sections: true
        toc: true
        toc_depth: 3
date: "`r format(Sys.time(), '%d %B, %Y')`"
---

```{{r setup}}
knitr::opts_knit$set(root.dir = '{envir}')
```

<style>
  .col2 {{
    columns: 2 200px;         /* number of columns and width in pixels*/
    -webkit-columns: 2 200px; /* chrome, safari */
    -moz-columns: 2 200px;    /* firefox */
  }}
  .col3 {{
    columns: 3 100px;
    -webkit-columns: 3 100px;
    -moz-columns: 3 100px;
  }}
</style>

# Data

```{{r}}
library(ggplot2)
library(feather)
library(reshape2)
library(bsselectR)
source('scripts/my_r.R')
info <- c('{model}', '{data}', 'motif_gradient')
pos <- read_feather('{input_p}')
pos <- reformat_grad(pos)
neg <- read_feather('{input_n}')
neg <- reformat_grad(neg)
```

# Overview

```{{r, echo=FALSE}}
p1 <- plot_gradient(pos, 'Positive')
p2 <- plot_gradient(neg, 'Negative')
multiplot(p1, p2)
```

# Correlation between motifs

```{{r, echo=FALSE}}
p1 <- cor_to_hist(pos, 'Positive')
p2 <- cor_to_hist(neg, 'Negative')
multiplot(p1, p2)
```

# Correlation between increase/decrease directions

```{{r, echo = FALSE}}
direction.cor <- list()
direction.cor.pos <- lapply(pos[!colnames(pos) %in% 'Direction'], function(x){{
    cor(x[pos$Direction == 'increase'], x[pos$Direction == 'decrease'])
}})
direction.cor$cor <- unlist(direction.cor.pos)
direction.cor$label <- rep('positive', length(direction.cor$cor))
direction.cor.neg <-  lapply(neg[!colnames(neg) %in% 'Direction'], function(x){{
    cor(x[neg$Direction == 'increase'], x[neg$Direction == 'decrease'])
}})
temp <- list()
temp$cor <- unlist(direction.cor.neg)
temp$label <- rep('negative', length(temp$cor))
direction.cor <- rbind(as.data.frame(direction.cor), as.data.frame(temp))
ggplot(direction.cor) + geom_violin(aes(x = label, y = cor)) + ggtitle('Distribution of correlation btw directions (increase/decrease)')
```

# Gradient per motif

```{{r, echo=FALSE}}
re <- plot_per_motif_grad_mean(pos, 'Positive')
p1 <- re$plot
mean.max.ordered <- re$mean.max
mean.min.ordered <- re$mean.min
motifs.ordered.pos <- re$motifs
plots.pos <- list()
for(i in 1 :  (length(motifs.ordered.pos))){{
    p <- plot_per_motif_grad(pos, motifs.ordered.pos[i], 'Positive', c(mean.max.ordered[i], mean.min.ordered[i]))
    plots.pos <- save_plot2(info, p, 'positive', motifs.ordered.pos[i], 'plots', plots.pos, '{envir}', i)
}}
re <- plot_per_motif_grad_mean(neg, 'Negative')
p2 <- re$plot
mean.max.ordered <- re$mean.max
mean.min.ordered <- re$mean.min
motifs.ordered.neg <- re$motifs
plots.neg <- list()
for(i in 1 : (length(motifs.ordered.neg))){{
    p <- plot_per_motif_grad(neg, motifs.ordered.neg[i], 'Negative', c(mean.max.ordered[i], mean.min.ordered[i]))
    plots.neg <- save_plot2(info, p, 'negative',  motifs.ordered.neg[i], 'plots', plots.neg, '{envir}', i)
}}
multiplot(p1, p2)
```

<div class="col2">
```{{r, echo=FALSE, warning=FALSE}}
bsselect(plots.pos, type = "img", selected = names(plots.pos)[1],
        live_search = TRUE, show_tick = TRUE, height = 5, width = 3,
        frame_height = 400, frame_width = 300)
bsselect(plots.neg, type = "img", selected = names(plots.neg)[1],
        live_search = TRUE, show_tick = TRUE, height = 5, width = 3,
        frame_height = 400, frame_width = 300)
```
</div>

'''.format(model=params.model, data=params.data, input_p=input.p, input_n=input.n, envir=params.envir)
        o = open(output.o, 'w')
        o.write(rmd)
        o.close()

rule report_grad_gen_html:
    input:
        rmd = 'report/{model}/{{dataname}}.{{data}}_motif_gradient.Rmd'.format(model=config['model']['name']),
        p = 'pattern/{model}/{{dataname}}.{{data}}/motif_gradient/pattern_positive.feather'.format(model=config['model']['name']),
        n = 'pattern/{model}/{{dataname}}.{{data}}/motif_gradient/pattern_negative.feather'.format(model=config['model']['name'])
    output:
        'report/{model}/{{dataname}}.{{data}}_motif_gradient.html'.format(model=config['model']['name'])
    shell:
        '''Rscript -e "rmarkdown::render('./{input.rmd}')"'''
